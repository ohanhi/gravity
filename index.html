<!DOCTYPE html>
<html>
<head>
  <title>Gravity</title>
  <script src="bower_components/Processing.js/processing.js"></script>
</head>
<body>

<h1>Gravity</h1>
<h2>Simple universal gravity simulation with processing.js</h2>

<p><canvas id="processing-canvas" width="800" height="600"></canvas></p>

<script type="text/javascript">

function sketchProc(P) {

  // BEGIN DEFINITIONS
  const CANVAS = {
    width: 640,
    height: 480
  },
  G_CONSTANT = 1.0,
  TIME_STEP = 0.15,
  COLLISION_RADIUS = 15.0;

  /**
  Newton's universal gravitation function.

  @link http://en.wikipedia.org/wiki/Newton's_law_of_universal_gravitation

  @param m1 mass of part 1
  @param m2 mass of part 2
  @param r distance between center of masses
  */
  const gravitation = function(m1, m2, r) {
    return G_CONSTANT * (m1*m2 / (r*r));
  };

  /**
  Converts mass to displayed size.
  */
  const massToSize = function(m) {
    return m * 2;
  };

  /**
  Converts mass to displayed color.
  */
  const massToColor = function(m) {
    return P.color((m*20)%256,255,255, 200);
  };

  function Part(x, y, vx, vy, m) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.m = m;
  }
  Part.prototype.move = function() {
    this.x += this.vx * TIME_STEP;
    this.y += this.vy * TIME_STEP;
  };
  Part.prototype.collide = function(part) {
    // totally inelastic collision
    this.vx = (this.m*this.vx + part.m*part.vx) / (this.m + part.m);
    this.vy = (this.m*this.vy + part.m*part.vy) / (this.m + part.m);
    this.m += part.m;
  };
  /*
  Determines the force from each part of the system and
  updates the velocities accordingly.
  */
  Part.prototype.updateVelocity = function(parts) {
    var self = this, ax = 0, ay = 0;
    parts.forEach(function(part, index){
      // distance of particles
      var dx = self.x-part.x,
      dy = self.y-part.y,
      r = Math.sqrt(
        dx*dx+
        dy*dy
      );

      // collision detection
      if (r && r < COLLISION_RADIUS) {
        self.collide(part);
        parts.splice(index, 1);
        return;
      }

      // gravitational force
      var f = gravitation(self.m, part.m, r);

      ax = (r===0)? 0 : (f * (dx/r)) / self.m;
      ay = (r===0)? 0 : (f * (dy/r)) / self.m;
      self.vx += ax * TIME_STEP * -1;
      self.vy += ay * TIME_STEP * -1;
    });
  };

  function PartSystem() {
    this.parts = [];
  }
  PartSystem.prototype.add = function(part) {
    this.parts.push(part);
  };
  PartSystem.prototype.update = function(draw) {
    var self = this;
    self.parts.forEach(function(part, index){
      // Update the position and speed of the part
      part.updateVelocity(self.parts);
      part.move();

      // Draw the part, if requested
      if (draw && draw === true) {
        var size = massToSize(part.m),
        color = massToColor(part.m);
        P.fill(color);
        P.ellipse(part.x, part.y, size, size);
      }
    });
  };
  PartSystem.prototype.redraw = function() {
    this.update(true);
  };
  PartSystem.prototype.randomizeParts = function(n, startVelocity) {
    for(var i = 0; i < n; i++) {
      var part = new Part(
        Math.random()*CANVAS.width,
        Math.random()*CANVAS.height,
        startVelocity ? Math.random()*10*randomPlusMinus() : 0,
        startVelocity ? Math.random()*10*randomPlusMinus() : 0,
        Math.random()*10 + 3
      );
      this.add(part);
    }
  };
  // END DEFINITIONS


  var ps = new PartSystem();
  ps.randomizeParts(100, true);

  P.setup = function() {
    P.size(CANVAS.width, CANVAS.height);
    P.ellipseMode(P.CENTER);
    P.colorMode(P.HSB);
  };

  // Override draw function, by default it will be called 60 times per second
  P.draw = function() {
    P.background(10);

    ps.redraw();
  };

}

var canvas = document.getElementById("processing-canvas");
// attaching the sketchProc function to the canvas
var processing = new Processing(canvas, sketchProc);
// processing.exit(); to detach it
</script>

</body>
</html>